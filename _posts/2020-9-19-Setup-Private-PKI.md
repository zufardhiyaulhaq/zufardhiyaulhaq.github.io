---
layout: post
title: Setup Private Public Key Infrastructure (PKI)
---

Over the past one week ago, I try to spike and setup private PKI in my lab environment mostly for ingress and gateway testing. There is a reason why I don't go with public one like Let's Encrypt because you need to buy a domain and host in ACME supported DNS01 challenge like AWS route53 and the pricing is too high.

Currently, I can resolve this problem by integrating multiple platform like:
- **step-ca**, online certificate authority for secure, automated certificate management.
- **CoreDNS**, as private DNS server.
- **acme-dns**, A simplified DNS server with a RESTful HTTP API to provide a simple way to automate ACME DNS01 challenges.

With this three platform (all running in Docker), I can have a private certificate generated by private root CA automatically via ACME DNS01 challenge with private domain all is done via certbot command like:

{% highlight shell %}
certbot certonly --manual --manual-auth-hook acme-dns-auth.py --preferred-challenges dns --debug-challenges -d server-1.zufar.io --server https://ca.zufar.io/acme/acme/directory
{% endhighlight %}

For Kubernetes, I use **cert-manager**, a native Kubernetes certificate management controller that support ACME protocol.

## Flow
below picture is the flow generate private certificate with private domain via certbot. In this example I will use:
- Certificate requested for server-1.zufar.io
- acme-dns resolve *.auth.zufar.io

![internal-pki]({{ site.baseurl }}/images/internal-pki.png)

1. User register with acme-dns, acme-dns will expose an limited random domain (example: `abcd.auth.zufar.io`).
2. acme-dns will return a JSON response contain a domain that exposed, username and password for API call to populate the domain with TXT record later.
3. User create a CNAME record in **CoreDNS** based on limited random domain that acme-dns give to the user.
    {% highlight shell %} _acme-challenge.server.zufar.io 	IN CNAME abcd.auth.zufar.io.{% endhighlight %}
4. Certbot request an certificate to the certificate authority step-ca (example: `server.zufar.io`). step-ca will request the certbot to prove that user is authorized with HTTP01 or DNS01 challenge.
5. Certbot will call acme-dns and populate the TXT record in `abcd.auth.zufar.io` with `key` that step-ca give.
6. Certbot will create a private key, create a CSR and send to certificate authority step-ca to sign the CSR.
7. step-ca will verify the authority by contacting DNS server to resolve `_acme-challenge.server-1.zufar.io` (CoreDNS in this case).
8. CoreDNS will resolve to `abcd.auth.zufar.io`. CoreDNS will forward this request to acme-dns via `subzone delegation` concept.
9. acme-dns resolve the DNS request and give the key in the TXT record
10. CoreDNS will send the result to step-ca.
11. step-ca verify the authority of the domain, sign the CSR and send the cert to the certbot.

## Setup CoreDNS
I use CoreDNS as the main DNS server in my lab. The configuration is pretty easy for me. You only need to provide the **Corefile** and **Zone file**. Also some modification in the docker entrypoint.

<script src="https://gist.github.com/zufardhiyaulhaq/1768cbdd0041190da86c876778a0a519.js"></script>

It is pretty simple right?

## Setup step-ca
Configuring step-ca probably is the most difficult one in this spike. In the **[official documentation running step-ca in docker](https://hub.docker.com/r/smallstep/step-ca)**, the first thing is we need to bootstrap the directory used by step-ca and run `step ca init` to create the whole infrastructure certificate like root CA and intermediate CA.

There is a problem in my side because I already have self signed root CA created and mounted in all my VM. `step ca init` can support `--root` and `--key` flag for exisiting root CA.

- Create a directory in your machine where you want to run the step-ca via docker (this will be mounted to the container)
- for simplicity, copy your root certificate and root private key (this is not recomended, please check **[this document](https://github.com/smallstep/certificates/blob/master/docs/questions.md#i-already-have-pki-in-place-can-i-use-this-with-my-own-root-certificate)** on how the `step ca init` actually works)
- Run initial docker container to bootstrap the directory
    {% highlight shell %} docker run -it -v $(pwd):/home/step smallstep/step-ca sh {% endhighlight %}
- Run the init command
    {% highlight shell %} step ca init --root=root-cert.pem --key=root-key.pem {% endhighlight %}
- Note your password and root fingerprint, also create a password file in the `secrets` directory
    {% highlight shell %} echo <your password here> > /home/step/secrets/password {% endhighlight %}
- Enable ACME support
    {% highlight shell %} step ca provisioner add acme --type ACME {% endhighlight %}
- Exit the initial container for bootstraping
    {% highlight shell %} exit{% endhighlight %}


