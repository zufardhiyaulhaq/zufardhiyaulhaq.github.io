---
layout: post
title: Setup Private Public Key Infrastructure (PKI)
---

Over the past one week ago, I try to spike and setup private PKI in my lab environment mostly for ingress and gateway testing. There is a reason why I don't go with public one like Let's Encrypt because you need to buy a domain and host in ACME supported DNS01 challenge like AWS route53 and the pricing is too high.

Currently, I can resolve this problem by integrating multiple platform like:
- **step-ca**, online certificate authority for secure, automated certificate management.
- **CoreDNS**, as private DNS server.
- **acme-dns**, A simplified DNS server with a RESTful HTTP API to provide a simple way to automate ACME DNS01 challenges.

With this three platform (all running in Docker), I can have a private certificate generated by private root CA automatically via ACME DNS01 challenge with private domain all is done via certbot command like:

{% highlight shell %}
certbot certonly --manual --manual-auth-hook acme-dns-auth.py --preferred-challenges dns --debug-challenges -d server-1.zufar.io --server https://ca.zufar.io/acme/acme/directory
{% endhighlight %}

For Kubernetes, I use **cert-manager**, a native Kubernetes certificate management controller that support ACME protocol.

## Flow
below picture is the flow generate private certificate with private domain via certbot. In this example I will use:
- Certificate requested for server.zufar.io
- acme-dns resolve *.auth.zufar.io

![internal-pki]({{ site.baseurl }}/images/internal-pki.png)

1. User register with acme-dns, acme-dns will expose an limited random domain (example: `abcd.auth.zufar.io`).
2. acme-dns will return a JSON response contain a domain that exposed, username and password for API call to populate the domain with TXT record later.
3. User create a CNAME record in **CoreDNS** based on limited random domain that acme-dns give to the user.
{% highlight shell %}
_acme-challenge.server.zufar.io 	IN CNAME abcd.auth.zufar.io.
{% endhighlight %}
4. Certbot request an certificate to the certificate authority step-ca (example: `server.zufar.io`). step-ca will request the certbot to prove that user is authorized with HTTP01 or DNS01 challenge.
5. Certbot will call acme-dns and populate the TXT record in `abcd.auth.zufar.io` with `key` that step-ca give.
6. Certbot will create a private key, create a CSR and send to certificate authority step-ca to sign the CSR.
7. step-ca will verify the authority by contacting DNS server to resolve `_acme-challenge.server.zufar.io` (CoreDNS in this case).
8. CoreDNS will resolve to `abcd.auth.zufar.io`. CoreDNS will forward this request to acme-dns via `subzone delegation` concept.
9. acme-dns resolve the DNS request and give the key in the TXT record
10. CoreDNS will send the result to step-ca.
11. step-ca verify the authority of the domain, sign the CSR and send the cert to the certbot.

## Setup CoreDNS
I use CoreDNS as the main DNS server in my lab. The configuration is pretty easy for me. You only need to provide the **Corefile** and **Zone file**. Also some modification in the docker entrypoint.

<script src="https://gist.github.com/zufardhiyaulhaq/1768cbdd0041190da86c876778a0a519.js"></script>
